// Copyright 2019 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"bytes"
	"encoding/json"
	"io"
	"net/http"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
)

func TestGetAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		args          []string
		expected      string
		expectedError string
		handler       http.Handler
	}{
		"when instance doesn't exist": {
			args: []string{"autoscale", "info", "-s", "my-service", "-i", "my-instance"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusNotFound)
				json.NewEncoder(w).Encode(autogenerated.Error{Msg: "instance \"my-instance\" not found"})
			}),
			expectedError: "could not get autoscale from RPaaS API: 404 Not Found",
		},

		"when autoscale is successfully returned": {
			args: []string{"autoscale", "info", "-s", "my-service", "-i", "my-instance"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(autogenerated.Autoscale{
					MinReplicas: 2,
					MaxReplicas: 5,
					Cpu:         autogenerated.PtrInt32(50),
					Memory:      autogenerated.PtrInt32(55),
					Rps:         autogenerated.PtrInt32(100),
				})
			}),
			expected: `+----------+----------------+
| Replicas | Target         |
+----------+----------------+
| Max: 5   | CPU: 50%       |
| Min: 2   | Memory: 55%    |
|          | RPS: 100 req/s |
+----------+----------------+
`,
		},

		"when get autoscale route is successful on JSON format": {
			args: []string{"autoscale", "info", "-s", "my-service", "-i", "my-instance", "--json"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				json.NewEncoder(w).Encode(autogenerated.Autoscale{
					MinReplicas: 2,
					MaxReplicas: 5,
					Cpu:         autogenerated.PtrInt32(50),
					Memory:      autogenerated.PtrInt32(55),
					Rps:         autogenerated.PtrInt32(100),
				})
			}),
			expected: `{
	"cpu": 50,
	"maxReplicas": 5,
	"memory": 55,
	"minReplicas": 2,
	"rps": 100
}
`,
		},
	}

	for _, serverGen := range AllRpaasAPIServerGenerators {
		t.Run("", func(t *testing.T) {
			for name, tt := range tests {
				t.Run(name, func(t *testing.T) {
					require.NotNil(t, tt.handler, "you must provide an HTTP handler")
					server, args := serverGen(t, tt.handler)
					defer server.Close()

					args = append(args, tt.args...)

					var stdout bytes.Buffer
					err := NewApp(&stdout, io.Discard, nil).Run(args)
					if tt.expectedError != "" {
						assert.EqualError(t, err, tt.expectedError)
						return
					}

					require.NoError(t, err)
					assert.Equal(t, tt.expected, stdout.String())
				})
			}
		})
	}
}

func TestRemoveAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		args          []string
		expected      string
		expectedError string
		handler       http.HandlerFunc
	}{
		"when instance doesn't exist": {
			args: []string{"autoscale", "remove", "-s", "my-service", "-i", "my-instance"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusNotFound)
				json.NewEncoder(w).Encode(autogenerated.Error{Msg: "instance \"my-instance\" not found"})
			}),
			expectedError: "could not delete the autoscale on RPaaS API: 404 Not Found",
		},

		"when autoscale is removed": {
			args: []string{"autoscale", "remove", "-s", "my-service", "-i", "my-instance"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusNoContent)
			}),
			expected: "Autoscale of my-service/my-instance successfully removed\n",
		},
	}

	for _, serverGen := range AllRpaasAPIServerGenerators {
		t.Run("", func(t *testing.T) {
			for name, tt := range tests {
				t.Run(name, func(t *testing.T) {
					require.NotNil(t, tt.handler, "you must provide an HTTP handler")
					server, args := serverGen(t, tt.handler)
					defer server.Close()

					args = append(args, tt.args...)

					var stdout bytes.Buffer
					err := NewApp(&stdout, io.Discard, nil).Run(args)
					if tt.expectedError != "" {
						assert.EqualError(t, err, tt.expectedError)
						return
					}
					require.NoError(t, err)
					assert.Equal(t, tt.expected, stdout.String())
				})
			}
		})
	}
}

func TestUpdateAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		args          []string
		expected      string
		expectedError string
		handler       http.HandlerFunc
	}{
		"when instance doesn't exist": {
			args: []string{"autoscale", "update", "-s", "my-service", "-i", "my-instance", "--min", "0", "--max", "10", "--cpu", "75"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusNotFound)
				json.NewEncoder(w).Encode(autogenerated.Error{Msg: "instance \"my-instance\" not found"})
			}),
			expectedError: "could not update the autoscale on RPaaS API: 404 Not Found",
		},

		"when autoscale is successufully updated": {
			args: []string{"autoscale", "update", "-s", "my-service", "-i", "my-instance", "--min", "0", "--max", "10", "--cpu", "75"},
			handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusNoContent)
			}),
			expected: "Autoscale of my-service/my-instance successfully updated!\n",
		},
	}

	for _, serverGen := range AllRpaasAPIServerGenerators {
		t.Run("", func(t *testing.T) {
			for name, tt := range tests {
				t.Run(name, func(t *testing.T) {
					require.NotNil(t, tt.handler, "you must provide an HTTP handler")
					server, args := serverGen(t, tt.handler)
					defer server.Close()

					args = append(args, tt.args...)

					var stdout bytes.Buffer
					err := NewApp(&stdout, io.Discard, nil).Run(args)
					if tt.expectedError != "" {
						assert.EqualError(t, err, tt.expectedError)
						return
					}
					require.NoError(t, err)
					assert.Equal(t, tt.expected, stdout.String())
				})
			}
		})
	}
}
